"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchFromChain = exports.fromChain = exports.idToChain = exports.toChain = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@cord.network/types");
const config_1 = require("@cord.network/config");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const utils_1 = require("@cord.network/utils");
const utils_2 = require("@cord.network/utils");
const Schema_js_1 = require("./Schema.js");
/**
 * Encodes the provided Schema for use in `api.tx.schema.add()`.
 *
 * @param schema The Schema to write on the blockchain.
 * @returns Encoded Schema.
 */
function toChain(schema) {
    return (0, Schema_js_1.serializeForHash)(schema);
}
exports.toChain = toChain;
/**
 * Encodes the provided Schema['$id'] for use in `api.query.schema.schemas()`.
 *
 * @param schemaId The Schema id to translate for the blockchain.
 * @returns Encoded Schema id.
 */
function idToChain(schemaId) {
    return utils_2.Identifier.uriToIdentifier(schemaId);
}
exports.idToChain = idToChain;
// Transform a blockchain-formatted Schema input (represented as Bytes) into the original [[ISchema]].
// It throws if what was written on the chain was garbage.
function schemaInputFromChain(input) {
    try {
        // Throws on invalid JSON input. Schema is expected to be a valid JSON document.
        const reconstructedObject = JSON.parse(input.toUtf8());
        const reconstructedSchemaId = utils_2.Identifier.hashToUri(reconstructedObject.schemaHash, types_1.SCHEMA_IDENTIFIER, types_1.SCHEMA_PREFIX);
        const reconstructedSchema = {
            ...reconstructedObject,
            $id: reconstructedSchemaId,
        };
        // If throws if the input was a valid JSON but not a valid Schema.
        (0, Schema_js_1.verifyDataStructure)(reconstructedSchema);
        return reconstructedSchema;
    }
    catch (cause) {
        throw new utils_1.SDKErrors.SchemaError(`The provided payload cannot be parsed as a Schema: ${input.toHuman()}`, { cause });
    }
}
/**
 * Decodes the Schema details returned by `api.query.schema.schemas()`.
 *
 * @param encoded The data from the blockchain.
 * @returns An object with on-chain Schema details.
 */
// eslint-disable-next-line jsdoc/require-jsdoc
function fromChain(encodedEntry) {
    if (encodedEntry.isSome) {
        const unwrapped = encodedEntry.unwrap();
        const { schema, digest, creator, createdAt } = unwrapped;
        return {
            schema: schemaInputFromChain(schema),
            schemaHash: digest.toHex(),
            creator: Did.fromChain(creator),
            createdAt: { height: createdAt.height, index: createdAt.index },
        };
    }
    return null;
}
exports.fromChain = fromChain;
/**
 * Resolves a Schema identifier to the Schema definition by fetching data from the block containing the transaction that registered the Schema on chain.
 *
 * @param schemaId Schema ID to use for the query. It is required to complement the information stored on the blockchain in a [[PalletSchemaSchemaEntry]].
 *
 * @returns The [[ISchemaDetails]].
 */
async function fetchFromChain(schemaId) {
    const api = config_1.ConfigService.get('api');
    const cordSchemaId = utils_2.Identifier.uriToIdentifier(schemaId);
    const schemaEntry = await api.query.schema.schemas(cordSchemaId);
    const decodedSchema = fromChain(schemaEntry);
    if (decodedSchema === null) {
        throw new utils_1.SDKErrors.SchemaError(`There is not a Schema with the provided ID "${schemaId}" on chain.`);
    }
    return decodedSchema;
}
exports.fetchFromChain = fetchFromChain;
