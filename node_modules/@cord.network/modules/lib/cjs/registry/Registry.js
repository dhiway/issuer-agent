"use strict";
/**
 * Registry.
 *
 * @packageDocumentation
 * @module Registry
 * @preferred
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toChain = exports.verifyStored = exports.isIRegistry = exports.fromRegistryProperties = exports.verifyRegistryDataStructure = void 0;
const utils_1 = require("@cord.network/utils");
const types_1 = require("@cord.network/types");
const config_1 = require("@cord.network/config");
/**
 *  Checks whether the input meets all the required criteria of an [[IRegistry]] object.
 *  Throws on invalid input.
 *
 * @param input The potentially only partial [[IRegistry]].
 *
 */
function verifyRegistryDataStructure(input) {
    if (!input.meta.schema) {
        throw new utils_1.SDKErrors.SchemaMissingError();
    }
    if (!input.meta.creator) {
        throw new utils_1.SDKErrors.CreatorMissingError();
    }
    if (!input.meta.digest) {
        throw new utils_1.SDKErrors.DataStructureError('registry hash not provided');
    }
    if (!input.details) {
        throw new utils_1.SDKErrors.ContentMissingError();
    }
    else {
        Object.entries(input.details).forEach(([key, value]) => {
            if (!key ||
                typeof key !== 'string' ||
                !['string', 'number', 'boolean', 'object'].includes(typeof value)) {
                throw new utils_1.SDKErrors.RegistryInputMalformedError();
            }
        });
    }
    utils_1.DataUtils.verifyIsHex(input.meta.digest, 256);
}
exports.verifyRegistryDataStructure = verifyRegistryDataStructure;
/**
   * Creates a new [[Registry]] from an [[IRegistryType]].
 
   *
   * @param space The request from which the [[Registry]] should be generated.
   * @param controller The identity of the [[Registry]] creator.
   * @returns An instance of [[Registry]].
   */
function fromRegistryProperties(registryProps) {
    const registryType = utils_1.jsonabc.sortObj({
        ...registryProps.details,
    });
    const encodedRegistry = utils_1.Crypto.encodeObjectAsStr(registryType);
    const registryHash = utils_1.Crypto.hashStr(encodedRegistry);
    const registryId = utils_1.Identifier.hashToUri(registryHash, types_1.REGISTRY_IDENT, types_1.REGISTRY_PREFIX);
    const registryDetails = {
        identifier: registryId,
        registryHash: registryHash,
        details: encodedRegistry,
    };
    const registryMeta = {
        digest: registryHash,
        schema: registryProps.schema,
        creator: registryProps.creator,
        active: true,
    };
    const registry = {
        identifier: registryId,
        details: registryDetails.details,
        meta: registryMeta,
    };
    verifyRegistryDataStructure(registry);
    return registry;
}
exports.fromRegistryProperties = fromRegistryProperties;
/**
 *  Custom Type Guard to determine input being of type ISpace using the SpaceUtils errorCheck.
 *
 * @param input The potentially only partial ISpace.
 * @returns Boolean whether input is of type ISpace.
 */
function isIRegistry(input) {
    try {
        verifyRegistryDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isIRegistry = isIRegistry;
/**
 * Checks on the CORD blockchain whether a schema is registered.
 *
 * @param schema Schema data.
 */
async function verifyStored(registry) {
    const api = config_1.ConfigService.get('api');
    const identifier = utils_1.Identifier.uriToIdentifier(registry.identifier);
    const encoded = await api.query.registry.registries(identifier);
    if (encoded.isNone)
        throw new utils_1.SDKErrors.RegistryIdentifierMissingError(`Registry with identifier ${identifier} is not registered on chain`);
}
exports.verifyStored = verifyStored;
/**
 * Encodes the provided Schema for use in `api.tx.schema.add()`.
 *
 * @param schema The Schema to write on the blockchain.
 * @returns Encoded Schema.
 */
function toChain(details) {
    return utils_1.Crypto.encodeObjectAsStr(details);
}
exports.toChain = toChain;
