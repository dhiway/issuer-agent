/// <reference types="bn.js" />
import type { Option } from '@polkadot/types';
import type { AccountId32, Extrinsic } from '@polkadot/types/interfaces';
import type { AnyNumber } from '@polkadot/types/types';
import { BN } from '@polkadot/util';
import type { DidDocument, DidServiceEndpoint, DidUri, DidVerificationKey, CordAddress, NewDidEncryptionKey, NewDidVerificationKey, SignExtrinsicCallback, SignRequestData, SignResponseData, SubmittableExtrinsic, UriFragment, VerificationKeyRelationship } from '@cord.network/types';
import type { PalletDidDidDetails, PalletDidDidDetailsDidPublicKey, PalletDidDidDetailsDidPublicKeyDetails, PalletDidServiceEndpointsDidEndpoint } from '@cord.network/augment-api';
import { EncodedEncryptionKey, EncodedSignature, EncodedVerificationKey } from './Did.utils.js';
export type ChainDidPublicKey = PalletDidDidDetailsDidPublicKey;
export type ChainDidPublicKeyDetails = PalletDidDidDetailsDidPublicKeyDetails;
/**
 * Format a DID to be used as a parameter for the blockchain API functions.

 * @param did The DID to format.
 * @returns The blockchain-formatted DID.
 */
export declare function toChain(did: DidUri): CordAddress;
/**
 * Format a DID resource ID to be used as a parameter for the blockchain API functions.

 * @param id The DID resource ID to format.
 * @returns The blockchain-formatted ID.
 */
export declare function resourceIdToChain(id: UriFragment): string;
type ChainDocument = Pick<DidDocument, 'authentication' | 'assertionMethod' | 'capabilityDelegation' | 'keyAgreement'> & {
    lastTxCounter: BN;
};
/**
 * Convert the DID data from blockchain format to the DID URI.
 *
 * @param encoded The chain-formatted DID.
 * @returns The DID URI.
 */
export declare function fromChain(encoded: AccountId32): DidUri;
/**
 * Convert the DID Document data from the blockchain format to a JS object.
 *
 * @param encoded The chain-formatted DID Document.
 * @returns The DID Document.
 */
export declare function documentFromChain(encoded: Option<PalletDidDidDetails>): ChainDocument;
interface ChainEndpoint {
    id: string;
    serviceTypes: DidServiceEndpoint['type'];
    urls: DidServiceEndpoint['serviceEndpoint'];
}
/**
 * Performs sanity checks on service endpoint data, making sure that the following conditions are met:
 *   - The `id` property is a string containing a valid URI fragment according to RFC#3986, not a complete DID URI.
 *   - If the `uris` property contains one or more strings, they must be valid URIs according to RFC#3986.
 *
 * @param endpoint A service endpoint object to check.
 */
export declare function validateService(endpoint: DidServiceEndpoint): void;
/**
 * Format the DID service to be used as a parameter for the blockchain API functions.
 *
 * @param service The DID service to format.
 * @returns The blockchain-formatted DID service.
 */
export declare function serviceToChain(service: DidServiceEndpoint): ChainEndpoint;
/**
 * Convert the DID service data coming from the blockchain to JS object.
 *
 * @param encoded The blockchain-formatted DID service data.
 * @returns The DID service.
 */
export declare function serviceFromChain(encoded: Option<PalletDidServiceEndpointsDidEndpoint>): DidServiceEndpoint;
export type AuthorizeCallInput = {
    did: DidUri;
    txCounter: AnyNumber;
    call: Extrinsic;
    submitter: CordAddress;
    blockNumber?: AnyNumber;
};
export declare function publicKeyToChain(key: NewDidVerificationKey): EncodedVerificationKey;
export declare function publicKeyToChain(key: NewDidEncryptionKey): EncodedEncryptionKey;
interface GetStoreTxInput {
    authentication: [NewDidVerificationKey];
    assertionMethod?: [NewDidVerificationKey];
    capabilityDelegation?: [NewDidVerificationKey];
    keyAgreement?: [NewDidEncryptionKey];
    service?: DidServiceEndpoint[];
}
export type GetStoreTxSignCallback = (signData: Omit<SignRequestData, 'did'>) => Promise<Omit<SignResponseData, 'keyUri'>>;
/**
 * Create a DID creation operation which includes the information provided.
 *
 * The resulting extrinsic can be submitted to create an on-chain DID that has the provided keys and service endpoints.
 *
 * A DID creation operation can contain at most 25 new service endpoints.
 * Additionally, each service endpoint must respect the following conditions:
 * - The service endpoint ID is at most 50 bytes long and is a valid URI fragment according to RFC#3986.
 * - The service endpoint has at most 1 service type, with a value that is at most 50 bytes long.
 * - The service endpoint has at most 1 URI, with a value that is at most 200 bytes long, and which is a valid URI according to RFC#3986.
 *
 * @param input The DID keys and services to store, also accepts DidDocument.
 * @param submitter The address authorized to submit the creation operation.
 * @param sign The sign callback. The authentication key has to be used.
 *
 * @returns The SubmittableExtrinsic for the DID creation operation.
 */
export declare function getStoreTx(input: GetStoreTxInput | DidDocument, submitter: CordAddress, sign: GetStoreTxSignCallback): Promise<SubmittableExtrinsic>;
export interface SigningOptions {
    sign: SignExtrinsicCallback;
    keyRelationship: VerificationKeyRelationship;
}
/**
 * DID related operations on the CORD blockchain require authorization by a DID. This is realized by requiring that relevant extrinsics are signed with a key featured by a DID as a verification method.
 * Such extrinsics can be produced using this function.
 *
 * @param params Object wrapping all input to the function.
 * @param params.did Full DID.
 * @param params.keyRelationship DID key relationship to be used for authorization.
 * @param params.sign The callback to interface with the key store managing the private key to be used.
 * @param params.call The call or extrinsic to be authorized.
 * @param params.txCounter The nonce or txCounter value for this extrinsic, which must be on larger than the current txCounter value of the authorizing DID.
 * @param params.submitter Payment account allowed to submit this extrinsic and cover its fees, which will end up owning any deposit associated with newly created records.
 * @param params.blockNumber Block number for determining the validity period of this authorization. If omitted, the current block number will be fetched from chain.
 * @returns A DID authorized extrinsic that, after signing with the payment account mentioned in the params, is ready for submission.
 */
export declare function generateDidAuthenticatedTx({ did, keyRelationship, sign, call, txCounter, submitter, blockNumber, }: AuthorizeCallInput & SigningOptions): Promise<SubmittableExtrinsic>;
/**
 * Compiles an enum-type key-value pair representation of a signature created with a DID verification method. Required for creating DID signed extrinsics.
 *
 * @param key Object describing data associated with a public key.
 * @param signature Object containing a signature generated with a DID associated public key.
 * @returns Data restructured to allow SCALE encoding by polkadot api.
 */
export declare function didSignatureToChain(key: DidVerificationKey, signature: Uint8Array): EncodedSignature;
export {};
