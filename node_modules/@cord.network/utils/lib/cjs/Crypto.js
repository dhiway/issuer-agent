"use strict";
/**
 * Crypto provides CORD with the utility types and methods useful for cryptographic operations, such as signing/verifying, encrypting/decrypting and hashing.
 *
 * The utility types and methods are wrappers for existing Polkadot functions and imported throughout the protocol for various cryptographic needs.
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeEncryptionKeypairFromSeed = exports.makeKeypairFromUri = exports.makeKeypairFromSeed = exports.hashStatements = exports.saltedBlake2b256 = exports.decryptAsymmetricAsStr = exports.decryptAsymmetric = exports.encryptAsymmetricAsStr = exports.encryptAsymmetric = exports.hashObjectAsHexStr = exports.encodeObjectAsStr = exports.hashStr = exports.hash = exports.verify = exports.signStr = exports.sign = exports.coToUInt8 = exports.u8aConcat = exports.u8aToHex = exports.decodeAddress = exports.encodeAddress = exports.mnemonicToMiniSecret = exports.mnemonicGenerate = exports.naclBoxPairFromSecret = void 0;
const tslib_1 = require("tslib");
const keyring_1 = require("@polkadot/keyring");
Object.defineProperty(exports, "decodeAddress", { enumerable: true, get: function () { return keyring_1.decodeAddress; } });
Object.defineProperty(exports, "encodeAddress", { enumerable: true, get: function () { return keyring_1.encodeAddress; } });
const util_1 = require("@polkadot/util");
Object.defineProperty(exports, "u8aConcat", { enumerable: true, get: function () { return util_1.u8aConcat; } });
Object.defineProperty(exports, "u8aToHex", { enumerable: true, get: function () { return util_1.u8aToHex; } });
const util_crypto_1 = require("@polkadot/util-crypto");
const api_1 = require("@polkadot/api");
const tweetnacl_1 = tslib_1.__importDefault(require("tweetnacl"));
const uuid_1 = require("uuid");
const jsonabc_js_1 = tslib_1.__importDefault(require("./jsonabc.js"));
const SDKErrors = tslib_1.__importStar(require("./SDKErrors.js"));
const ss58Format_js_1 = require("./ss58Format.js");
var util_crypto_2 = require("@polkadot/util-crypto");
Object.defineProperty(exports, "naclBoxPairFromSecret", { enumerable: true, get: function () { return util_crypto_2.naclBoxPairFromSecret; } });
Object.defineProperty(exports, "mnemonicGenerate", { enumerable: true, get: function () { return util_crypto_2.mnemonicGenerate; } });
Object.defineProperty(exports, "mnemonicToMiniSecret", { enumerable: true, get: function () { return util_crypto_2.mnemonicToMiniSecret; } });
/**
 * Creates a Uint8Array value from a Uint8Array, Buffer, string or hex input.
 *
 * @param input Input array or string. Null or undefined result in an empty array.
 * @param hexAsString Whether or not a hex string is encoded as a string instead of a number.
 * @returns A (possibly empty) Uint8Array.
 */
function coToUInt8(input, hexAsString = false) {
    if (hexAsString && (0, util_1.isString)(input)) {
        return (0, util_1.stringToU8a)(input);
    }
    return (0, util_1.u8aToU8a)(input);
}
exports.coToUInt8 = coToUInt8;
/**
 * Signs a message.
 *
 * @param message String or byte array to be signed.
 * @param signKeyPair KeyringPair used for signing.
 * @returns Signature over message as byte array.
 */
function sign(message, signKeyPair) {
    return signKeyPair.sign(coToUInt8(message), { withType: true });
}
exports.sign = sign;
/**
 * Signs a message. Returns signature string.
 *
 * @param message String or byte array to be signed.
 * @param signKeyPair KeyringPair used for signing.
 * @returns Signature over message as hex string.
 */
function signStr(message, signKeyPair) {
    return (0, util_1.u8aToHex)(sign(message, signKeyPair));
}
exports.signStr = signStr;
/**
 * Verifies a signature over a message.
 *
 * @param message Original signed message to be verified.
 * @param signature Signature as hex string or byte array.
 * @param addressOrPublicKey Substrate address or public key of the signer.
 */
function verify(message, signature, addressOrPublicKey) {
    if ((0, util_crypto_1.signatureVerify)(message, signature, addressOrPublicKey).isValid !== true)
        throw new SDKErrors.SignatureUnverifiableError();
}
exports.verify = verify;
/**
 * Create the blake2b and return the result as an u8a with the specified `bitLength`.
 *
 * @param value Value to be hashed.
 * @param bitLength Bit length of hash.
 * @returns Blake2b hash byte array.
 */
function hash(value, bitLength) {
    return (0, util_crypto_1.blake2AsU8a)(value, bitLength);
}
exports.hash = hash;
/**
 * Create the blake2b and return the result as a hex string.
 *
 * @param value Value to be hashed.
 * @returns Blake2b hash as hex string.
 */
function hashStr(value, bitLength) {
    return (0, util_1.u8aToHex)(hash(value, bitLength));
}
exports.hashStr = hashStr;
/**
 * Stringifies numbers, booleans, and objects. Object keys are sorted to yield consistent hashing.
 *
 * @param value Object or value to be hashed.
 * @returns Stringified representation of the given object.
 */
function encodeObjectAsStr(value) {
    const input = 
    // eslint-disable-next-line no-nested-ternary
    typeof value === 'object' && value !== null
        ? JSON.stringify(jsonabc_js_1.default.sortObj(value))
        : // eslint-disable-next-line no-nested-ternary
            typeof value === 'number' && value !== null
                ? value.toString()
                : typeof value === 'boolean' && value !== null
                    ? JSON.stringify(value)
                    : value;
    return input.normalize('NFC');
}
exports.encodeObjectAsStr = encodeObjectAsStr;
/**
 * Hashes numbers, booleans, and objects by stringifying them. Object keys are sorted to yield consistent hashing.
 *
 * @param value Object or value to be hashed.
 * @param nonce Optional nonce to obscure hashed values that could be guessed.
 * @returns Blake2b hash as hex string.
 */
function hashObjectAsHexStr(value, bitLength, nonce) {
    let objectAsStr = encodeObjectAsStr(value);
    if (nonce) {
        objectAsStr = nonce + objectAsStr;
    }
    return hashStr(objectAsStr, bitLength);
}
exports.hashObjectAsHexStr = hashObjectAsHexStr;
/**
 * Wrapper around nacl.box. Authenticated encryption of a message for a recipient's public key.
 *
 * @param message String or byte array to be encrypted.
 * @param publicKeyA Public key of the recipient. The owner will be able to decrypt the message.
 * @param secretKeyB Private key of the sender. Necessary to authenticate the message during decryption.
 * @returns Encrypted message and nonce used for encryption.
 */
function encryptAsymmetric(message, publicKeyA, secretKeyB) {
    const nonce = tweetnacl_1.default.randomBytes(24);
    const box = tweetnacl_1.default.box(coToUInt8(message, true), nonce, coToUInt8(publicKeyA), coToUInt8(secretKeyB));
    return { box, nonce };
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Wrapper around nacl.box. Authenticated encryption of a message for a recipient's public key.
 *
 * @param message String or byte array to be encrypted.
 * @param publicKeyA Public key of the recipient. The owner will be able to decrypt the message.
 * @param secretKeyB Private key of the sender. Necessary to authenticate the message during decryption.
 * @returns Encrypted message and nonce used for encryption as hex strings.
 */
function encryptAsymmetricAsStr(message, publicKeyA, secretKeyB) {
    const encrypted = encryptAsymmetric(message, publicKeyA, secretKeyB);
    const box = (0, util_1.u8aToHex)(encrypted.box);
    const nonce = (0, util_1.u8aToHex)(encrypted.nonce);
    return { box, nonce };
}
exports.encryptAsymmetricAsStr = encryptAsymmetricAsStr;
/**
 * Wrapper around nacl.box.open. Authenticated decryption of an encrypted message.
 *
 * @param data Object containing encrypted message and nonce used for encryption.
 * @param publicKeyB Public key of the sender. Necessary to authenticate the message during decryption.
 * @param secretKeyA Private key of the recipient. Required for decryption.
 * @returns Decrypted message or false if decryption is unsuccessful.
 */
function decryptAsymmetric(data, publicKeyB, secretKeyA) {
    const decrypted = tweetnacl_1.default.box.open(coToUInt8(data.box), coToUInt8(data.nonce), coToUInt8(publicKeyB), coToUInt8(secretKeyA));
    return decrypted || false;
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Wrapper around nacl.box.open. Authenticated decryption of an encrypted message.
 *
 * @param data Object containing encrypted message and nonce used for encryption.
 * @param publicKeyB Public key of the sender. Necessary to authenticate the message during decryption.
 * @param secretKeyA Private key of the recipient. Required for decryption.
 * @returns Decrypted message as string or false if decryption is unsuccessful.
 */
function decryptAsymmetricAsStr(data, publicKeyB, secretKeyA) {
    const result = decryptAsymmetric(data, coToUInt8(publicKeyB), coToUInt8(secretKeyA));
    return result !== false ? (0, util_1.u8aToString)(result) : false;
}
exports.decryptAsymmetricAsStr = decryptAsymmetricAsStr;
/**
 * Default hasher for [[hashStatements]].
 *
 * @param value String to be hashed.
 * @param nonce Optional nonce (as string) used to obscure hashed contents.
 * @returns 256 bit blake2 hash as hex string.
 */
function saltedBlake2b256(value, nonce = '') {
    return (0, util_crypto_1.blake2AsHex)(nonce + value, 256);
}
exports.saltedBlake2b256 = saltedBlake2b256;
/**
 * Configurable computation of salted over an array of statements. Can be used to validate/reproduce salted hashes
 * by means of an optional nonce map.
 *
 * @param statements An array of statement strings to be hashed.
 * @param options Optional hasher arguments.
 * @param options.nonces An optional map or array of nonces. If present, it should comprise all keys of `statements`, as those will be used map nonces to statements.
 * @param options.nonceGenerator An optional nonce generator. Will be used if `options.nonces` is not defined to generate a (new) nonce for each statement. The statement key is passed as its first argument. If no `nonces` or `nonceGenerator` are given this function returns unsalted hashes.
 * @param options.hasher The hasher to be used. Computes a hash from a statement and an optional nonce. Required but defaults to 256 bit blake2 over `${nonce}${statement}`.
 * @returns An array of objects for each statement which contain a statement, its digest, salted hash and nonce.
 */
function hashStatements(statements, options = {}) {
    // apply defaults
    const defaults = {
        hasher: saltedBlake2b256,
        nonceGenerator: () => (0, uuid_1.v4)(),
    };
    const hasher = options.hasher || defaults.hasher;
    const nonceGenerator = options.nonceGenerator || defaults.nonceGenerator;
    // set source for nonces
    const { nonces } = options;
    const getNonce = typeof nonces === 'object' ? (key) => nonces[key] : nonceGenerator;
    // iterate over statements to produce salted hashes
    return statements.map((statement) => {
        // generate unsalted digests from statements as a first step
        const digest = hasher(statement);
        // if nonces were passed, they would be mapped to the statement via its digest
        const nonce = getNonce(digest);
        // to simplify validation, the salted hash is computed over unsalted hash (nonce key) & nonce
        const saltedHash = hasher(digest, nonce);
        return { digest, saltedHash, nonce, statement };
    });
}
exports.hashStatements = hashStatements;
/**
 * Generate typed CORD blockchain keypair from a seed or random data.
 *
 * @param seed The keypair seed, only optional in the tests.
 * @param type Optional type of the keypair.
 * @returns The keypair.
 */
function makeKeypairFromSeed(seed = (0, util_crypto_1.randomAsU8a)(32), type) {
    const keyring = new api_1.Keyring({ ss58Format: ss58Format_js_1.ss58Format, type });
    return keyring.addFromSeed(seed);
}
exports.makeKeypairFromSeed = makeKeypairFromSeed;
/**
 * Generate typed CORD blockchain keypair from a polkadot keypair URI.
 *
 * @param uri The URI.
 * @param type Optional type of the keypair.
 * @returns The keypair.
 */
function makeKeypairFromUri(uri, type) {
    const keyring = new api_1.Keyring({ ss58Format: ss58Format_js_1.ss58Format, type });
    return keyring.addFromUri(uri);
}
exports.makeKeypairFromUri = makeKeypairFromUri;
/**
 * Generate from a seed a x25519 keypair to be used as DID encryption key.
 *
 * @param seed The keypair seed, only optional in the tests.
 * @returns The keypair.
 */
function makeEncryptionKeypairFromSeed(seed = (0, util_crypto_1.randomAsU8a)(32)) {
    return {
        ...(0, util_crypto_1.naclBoxPairFromSecret)(seed),
        type: 'x25519',
    };
}
exports.makeEncryptionKeypairFromSeed = makeEncryptionKeypairFromSeed;
