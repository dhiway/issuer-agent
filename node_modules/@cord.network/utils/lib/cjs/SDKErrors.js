"use strict";
/**
 * SDKErrors are CORD-specific errors, with associated codes and descriptions.
 *
 * @packageDocumentation
 * @module SDKErrors
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidProofForStatementError = exports.HashMalformedError = exports.IdentifierInvalidError = exports.AddressInvalidError = exports.DidSubjectMismatchError = exports.InvalidDidFormatError = exports.UnknownMessageBodyTypeError = exports.IdentityMismatchError = exports.DataStructureError = exports.SchemaMissingError = exports.DelegateMissingError = exports.RegistryInputMalformedError = exports.CreatorMissingError = exports.ContentNonceMapMalformedError = exports.CredentialUnverifiableError = exports.IssuerMissingError = exports.StreamHashMissingError = exports.IdentifierMissingError = exports.HashTypeError = exports.ContentMissingError = exports.ContentNonceMapMissingError = exports.EvidenceMissingError = exports.SubjectMissingError = exports.HolderMissingError = exports.RevokedTypeError = exports.ContentHashMissingError = exports.RootHashUnverifiableError = exports.NestedContentUnverifiableError = exports.SchemaIdMismatchError = exports.RegistryIdentifierMissingError = exports.SchemaIdentifierMissingError = exports.SchemaUnknownPropertiesError = exports.SchemaError = exports.SchemaIdMissingError = exports.ObjectUnverifiableError = exports.SignatureUnverifiableError = exports.SignatureMalformedError = exports.AddressTypeError = exports.DidDeactivatedError = exports.DidResolveUpgradedDidError = exports.DidNotFoundError = exports.DidBatchError = exports.DidExporterError = exports.DidError = exports.EncryptionError = exports.InputContentsMalformedError = exports.BlockchainApiMissingError = exports.UnsupportedKeyError = exports.UnauthorizedError = exports.SDKError = void 0;
exports.CodecMismatchError = exports.TimeoutError = exports.DecodingMessageError = exports.SubscriptionsNotSupportedError = exports.ContentUnverifiableError = exports.NoProofForStatementError = void 0;
/* eslint-disable max-classes-per-file */
class SDKError extends Error {
    constructor(...args) {
        super(...args);
        this.name = this.constructor.name;
    }
}
exports.SDKError = SDKError;
class UnauthorizedError extends SDKError {
}
exports.UnauthorizedError = UnauthorizedError;
class UnsupportedKeyError extends SDKError {
    constructor(keyType) {
        super(`The provided key type "${keyType}" is currently not supported`);
    }
}
exports.UnsupportedKeyError = UnsupportedKeyError;
class BlockchainApiMissingError extends SDKError {
    constructor(options) {
        super('The Chain API is not set. Did you forget to call `Cord.connect(…)` or `Cord.init(…)`?', options);
    }
}
exports.BlockchainApiMissingError = BlockchainApiMissingError;
class InputContentsMalformedError extends SDKError {
}
exports.InputContentsMalformedError = InputContentsMalformedError;
class EncryptionError extends SDKError {
}
exports.EncryptionError = EncryptionError;
class DidError extends SDKError {
}
exports.DidError = DidError;
class DidExporterError extends SDKError {
}
exports.DidExporterError = DidExporterError;
class DidBatchError extends SDKError {
}
exports.DidBatchError = DidBatchError;
class DidNotFoundError extends SDKError {
}
exports.DidNotFoundError = DidNotFoundError;
class DidResolveUpgradedDidError extends SDKError {
}
exports.DidResolveUpgradedDidError = DidResolveUpgradedDidError;
class DidDeactivatedError extends SDKError {
}
exports.DidDeactivatedError = DidDeactivatedError;
class AddressTypeError extends SDKError {
}
exports.AddressTypeError = AddressTypeError;
class SignatureMalformedError extends SDKError {
}
exports.SignatureMalformedError = SignatureMalformedError;
class SignatureUnverifiableError extends SDKError {
}
exports.SignatureUnverifiableError = SignatureUnverifiableError;
class ObjectUnverifiableError extends SDKError {
}
exports.ObjectUnverifiableError = ObjectUnverifiableError;
class SchemaIdMissingError extends SDKError {
}
exports.SchemaIdMissingError = SchemaIdMissingError;
class SchemaError extends SDKError {
}
exports.SchemaError = SchemaError;
class SchemaUnknownPropertiesError extends SDKError {
}
exports.SchemaUnknownPropertiesError = SchemaUnknownPropertiesError;
class SchemaIdentifierMissingError extends SDKError {
}
exports.SchemaIdentifierMissingError = SchemaIdentifierMissingError;
class RegistryIdentifierMissingError extends SDKError {
}
exports.RegistryIdentifierMissingError = RegistryIdentifierMissingError;
class SchemaIdMismatchError extends SDKError {
    constructor(fromSchema, provided) {
        super(`Provided $id "${provided}" does not match schema $id "${fromSchema}"`);
    }
}
exports.SchemaIdMismatchError = SchemaIdMismatchError;
class NestedContentUnverifiableError extends SDKError {
}
exports.NestedContentUnverifiableError = NestedContentUnverifiableError;
class RootHashUnverifiableError extends SDKError {
}
exports.RootHashUnverifiableError = RootHashUnverifiableError;
class ContentHashMissingError extends SDKError {
}
exports.ContentHashMissingError = ContentHashMissingError;
class RevokedTypeError extends SDKError {
}
exports.RevokedTypeError = RevokedTypeError;
class HolderMissingError extends SDKError {
}
exports.HolderMissingError = HolderMissingError;
class SubjectMissingError extends SDKError {
}
exports.SubjectMissingError = SubjectMissingError;
class EvidenceMissingError extends SDKError {
}
exports.EvidenceMissingError = EvidenceMissingError;
class ContentNonceMapMissingError extends SDKError {
}
exports.ContentNonceMapMissingError = ContentNonceMapMissingError;
class ContentMissingError extends SDKError {
}
exports.ContentMissingError = ContentMissingError;
class HashTypeError extends SDKError {
}
exports.HashTypeError = HashTypeError;
class IdentifierMissingError extends SDKError {
}
exports.IdentifierMissingError = IdentifierMissingError;
class StreamHashMissingError extends SDKError {
}
exports.StreamHashMissingError = StreamHashMissingError;
class IssuerMissingError extends SDKError {
}
exports.IssuerMissingError = IssuerMissingError;
class CredentialUnverifiableError extends SDKError {
}
exports.CredentialUnverifiableError = CredentialUnverifiableError;
class ContentNonceMapMalformedError extends SDKError {
    constructor(statement) {
        if (statement) {
            super(`Nonce map malformed or incomplete for statement "${statement}"`);
        }
        else {
            super(`Nonce map malformed or incomplete`);
        }
    }
}
exports.ContentNonceMapMalformedError = ContentNonceMapMalformedError;
class CreatorMissingError extends SDKError {
}
exports.CreatorMissingError = CreatorMissingError;
class RegistryInputMalformedError extends SDKError {
}
exports.RegistryInputMalformedError = RegistryInputMalformedError;
class DelegateMissingError extends SDKError {
}
exports.DelegateMissingError = DelegateMissingError;
class SchemaMissingError extends SDKError {
}
exports.SchemaMissingError = SchemaMissingError;
class DataStructureError extends SDKError {
}
exports.DataStructureError = DataStructureError;
class IdentityMismatchError extends SDKError {
    constructor(context, type) {
        if (type && context) {
            super(`${type} is not owner of the ${context}`);
        }
        else if (context) {
            super(`Identity is not owner of the ${context}`);
        }
        else {
            super('Addresses expected to be equal mismatched');
        }
    }
}
exports.IdentityMismatchError = IdentityMismatchError;
class UnknownMessageBodyTypeError extends SDKError {
}
exports.UnknownMessageBodyTypeError = UnknownMessageBodyTypeError;
class InvalidDidFormatError extends SDKError {
    constructor(did, options) {
        super(`Not a valid CORD DID "${did}"`, options);
    }
}
exports.InvalidDidFormatError = InvalidDidFormatError;
class DidSubjectMismatchError extends SDKError {
    constructor(actual, expected) {
        super(`The DID "${actual}" doesn't match the DID Document's URI "${expected}"`);
    }
}
exports.DidSubjectMismatchError = DidSubjectMismatchError;
class AddressInvalidError extends SDKError {
    constructor(id, type) {
        if (id && type) {
            super(`Provided ${type} identifier "${id}" is invalid`);
        }
        else if (id) {
            super(`Provided identifier "${id}" is invalid`);
        }
        else {
            super(`Provided identifier invalid`);
        }
    }
}
exports.AddressInvalidError = AddressInvalidError;
class IdentifierInvalidError extends SDKError {
    constructor(address, type) {
        if (address && type) {
            super(`Provided ${type} address "${address}" is invalid`);
        }
        else if (address) {
            super(`Provided address "${address}" is invalid`);
        }
        else {
            super(`Provided address invalid`);
        }
    }
}
exports.IdentifierInvalidError = IdentifierInvalidError;
class HashMalformedError extends SDKError {
    constructor(hash, type) {
        if (hash && type) {
            super(`Provided ${type} hash "${hash}" is invalid or malformed`);
        }
        else if (hash) {
            super(`Provided hash "${hash}" is invalid or malformed`);
        }
        else {
            super('Provided hash invalid or malformed');
        }
    }
}
exports.HashMalformedError = HashMalformedError;
class InvalidProofForStatementError extends SDKError {
    constructor(statement) {
        super(`Proof could not be verified for statement:\n${statement}`);
    }
}
exports.InvalidProofForStatementError = InvalidProofForStatementError;
class NoProofForStatementError extends SDKError {
    constructor(statement) {
        super(`No matching proof found for statement:\n${statement}`);
    }
}
exports.NoProofForStatementError = NoProofForStatementError;
class ContentUnverifiableError extends SDKError {
}
exports.ContentUnverifiableError = ContentUnverifiableError;
class SubscriptionsNotSupportedError extends SDKError {
    constructor(options) {
        super('This function is not available if the blockchain API does not support state or event subscriptions, use `WsProvider` to enable the complete feature set', options);
    }
}
exports.SubscriptionsNotSupportedError = SubscriptionsNotSupportedError;
class DecodingMessageError extends SDKError {
}
exports.DecodingMessageError = DecodingMessageError;
class TimeoutError extends SDKError {
}
exports.TimeoutError = TimeoutError;
class CodecMismatchError extends SDKError {
}
exports.CodecMismatchError = CodecMismatchError;
